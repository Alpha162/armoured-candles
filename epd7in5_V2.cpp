#include <stdlib.h>
#include "epd7in5_V2.h"

static unsigned char Voltage_Frame_7IN5_V2[] = {
    0x6, 0x3F, 0x3F, 0x11, 0x24, 0x7, 0x17,
};

static unsigned char LUT_VCOM_7IN5_V2[] = {
    0x0,0xF,0xF,0x0,0x0,0x1, 0x0,0xF,0x1,0xF,0x1,0x2,
    0x0,0xF,0xF,0x0,0x0,0x1, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,
};

static unsigned char LUT_WW_7IN5_V2[] = {
    0x10,0xF,0xF,0x0,0x0,0x1, 0x84,0xF,0x1,0xF,0x1,0x2,
    0x20,0xF,0xF,0x0,0x0,0x1, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,
};

static unsigned char LUT_BW_7IN5_V2[] = {
    0x10,0xF,0xF,0x0,0x0,0x1, 0x84,0xF,0x1,0xF,0x1,0x2,
    0x20,0xF,0xF,0x0,0x0,0x1, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,
};

static unsigned char LUT_WB_7IN5_V2[] = {
    0x80,0xF,0xF,0x0,0x0,0x1, 0x84,0xF,0x1,0xF,0x1,0x2,
    0x40,0xF,0xF,0x0,0x0,0x1, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,
};

static unsigned char LUT_BB_7IN5_V2[] = {
    0x80,0xF,0xF,0x0,0x0,0x1, 0x84,0xF,0x1,0xF,0x1,0x2,
    0x40,0xF,0xF,0x0,0x0,0x1, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,
};

Epd::~Epd() {};

Epd::Epd() {
    reset_pin = RST_PIN;
    dc_pin = DC_PIN;
    cs_pin = CS_PIN;
    busy_pin = BUSY_PIN;
    width = EPD_WIDTH;
    height = EPD_HEIGHT;
};

int Epd::Init(void) {
    Serial.println("  IfInit...");
    if (IfInit() != 0) return -1;
    Serial.println("  Reset...");
    Reset();

    Serial.println("  Power settings...");
    SendCommand(0x01);
    SendData(0x17);
    SendData(*(Voltage_Frame_7IN5_V2+6));
    SendData(*(Voltage_Frame_7IN5_V2+1));
    SendData(*(Voltage_Frame_7IN5_V2+2));
    SendData(*(Voltage_Frame_7IN5_V2+3));

    SendCommand(0x82);
    SendData(*(Voltage_Frame_7IN5_V2+4));

    SendCommand(0x06);
    SendData(0x27); SendData(0x27); SendData(0x2F); SendData(0x17);

    SendCommand(0x30);
    SendData(*(Voltage_Frame_7IN5_V2+0));

    Serial.println("  Power ON (0x04)...");
    SendCommand(0x04);
    DelayMs(100);
    WaitUntilIdle();

    Serial.println("  Panel config...");
    SendCommand(0X00); SendData(0x3F);
    SendCommand(0x61); SendData(0x03); SendData(0x20); SendData(0x01); SendData(0xE0);
    SendCommand(0X15); SendData(0x00);
    SendCommand(0X50); SendData(0x10); SendData(0x00);
    SendCommand(0X60); SendData(0x22);
    SendCommand(0x65); SendData(0x00); SendData(0x00); SendData(0x00); SendData(0x00);

    Serial.println("  LUT...");
    SetLut_by_host(LUT_VCOM_7IN5_V2, LUT_WW_7IN5_V2, LUT_BW_7IN5_V2, LUT_WB_7IN5_V2, LUT_BB_7IN5_V2);
    Serial.println("  Init complete");
    return 0;
}

void Epd::SendCommand(unsigned char command) {
    DigitalWrite(dc_pin, LOW);
    SpiTransfer(command);
}

void Epd::SendData(unsigned char data) {
    DigitalWrite(dc_pin, HIGH);
    SpiTransfer(data);
}

void Epd::WaitUntilIdle(void) {
    unsigned char busy;
    Serial.print("e-Paper Busy\r\n");
    unsigned long start = millis();
    do {
        SendCommand(0x71);
        busy = DigitalRead(busy_pin);
        if (millis() - start > 20000) {  // 20s timeout
            Serial.print("e-Paper TIMEOUT!\r\n");
            return;
        }
    } while(busy == 0);
    Serial.print("e-Paper Busy Release\r\n");
    DelayMs(20);
}

void Epd::Reset(void) {
    DigitalWrite(reset_pin, HIGH); DelayMs(20);
    DigitalWrite(reset_pin, LOW);  DelayMs(2);   // short pulse — Rev 2.3 powers off on long low
    DigitalWrite(reset_pin, HIGH); DelayMs(200);  // longer recovery after deep sleep
}

void Epd::DisplayFrame(const unsigned char* frame_buffer) {
    // Send old data (0x10) as all white for full refresh
    SendCommand(0x10);
    unsigned char whiteRow[100];
    memset(whiteRow, 0x00, 100);  // after inversion = white
    DigitalWrite(dc_pin, HIGH);
    for (unsigned long j = 0; j < height; j++) {
        SpiTransferBulk(whiteRow, 100);
    }

    // Send new data (0x13)
    SendCommand(0x13);
    unsigned char row[100];
    DigitalWrite(dc_pin, HIGH);
    for (unsigned long j = 0; j < height; j++) {
        for (unsigned long i = 0; i < 100; i++) {
            row[i] = ~frame_buffer[i + j * 100];
        }
        SpiTransferBulk(row, 100);
    }
    SendCommand(0x12);
    DelayMs(100);
    WaitUntilIdle();
}

void Epd::DisplayFramePartial(const unsigned char* old_buf, const unsigned char* new_buf) {
    // Partial refresh LUT — single phase, no flash
    // Only drives pixels that differ between old and new
    static unsigned char lut_vcom_partial[] = {
        0x00,0x19,0x01,0x00,0x00,0x01,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
    };
    static unsigned char lut_ww_partial[] = {
        0x00,0x19,0x01,0x00,0x00,0x01,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
    };
    static unsigned char lut_bw_partial[] = {
        0x80,0x19,0x01,0x00,0x00,0x01,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
    };
    static unsigned char lut_wb_partial[] = {
        0x40,0x19,0x01,0x00,0x00,0x01,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
    };
    static unsigned char lut_bb_partial[] = {
        0x00,0x19,0x01,0x00,0x00,0x01,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,
    };

    // Load partial LUT
    SetLut_by_host(lut_vcom_partial, lut_ww_partial, lut_bw_partial, lut_wb_partial, lut_bb_partial);

    // VCOM data interval for partial
    SendCommand(0x50);
    SendData(0x10);
    SendData(0x00);

    // Send OLD data (0x10) — what's currently on screen
    SendCommand(0x10);
    unsigned char row[100];
    DigitalWrite(dc_pin, HIGH);
    for (unsigned long j = 0; j < height; j++) {
        for (unsigned long i = 0; i < 100; i++) {
            row[i] = ~old_buf[i + j * 100];
        }
        SpiTransferBulk(row, 100);
    }

    // Send NEW data (0x13)
    SendCommand(0x13);
    DigitalWrite(dc_pin, HIGH);
    for (unsigned long j = 0; j < height; j++) {
        for (unsigned long i = 0; i < 100; i++) {
            row[i] = ~new_buf[i + j * 100];
        }
        SpiTransferBulk(row, 100);
    }

    SendCommand(0x12);
    DelayMs(100);
    WaitUntilIdle();

    // Restore full-refresh LUT for next time if needed
    // (will be overwritten by Init on full refresh anyway)
}

void Epd::Clear(void) {
    SendCommand(0x13);
    unsigned char row[100] = {0};
    DigitalWrite(dc_pin, HIGH);
    for (unsigned long j = 0; j < height; j++) {
        SpiTransferBulk(row, 100);
    }
    SendCommand(0x12);
    DelayMs(100);
    WaitUntilIdle();
}

void Epd::SetLut_by_host(unsigned char* lut_vcom, unsigned char* lut_ww,
                          unsigned char* lut_bw, unsigned char* lut_wb, unsigned char* lut_bb) {
    unsigned char count;
    SendCommand(0x20); for(count=0;count<42;count++) SendData(lut_vcom[count]);
    SendCommand(0x21); for(count=0;count<42;count++) SendData(lut_ww[count]);
    SendCommand(0x22); for(count=0;count<42;count++) SendData(lut_bw[count]);
    SendCommand(0x23); for(count=0;count<42;count++) SendData(lut_wb[count]);
    SendCommand(0x24); for(count=0;count<42;count++) SendData(lut_bb[count]);
}

void Epd::Sleep(void) {
    SendCommand(0X02);
    WaitUntilIdle();
    SendCommand(0X07);
    SendData(0xA5);
}
